#!-------------------------------------------------------------------------------------------------!
#!   CP2K: A general program to perform molecular dynamics simulations                             !
#!   Copyright (C) 2000 - 2017  CP2K developers group                                              !
#!-------------------------------------------------------------------------------------------------!
#:mute

#:def colloc_int_kloop(grad_val=None, FMG_INTEGRATE_FULL=False, FMG_INTEGRATE=False, FM_FLAT_GRID=False)

#!--------------------------------------------------------------------------------------------------
#:def kgrad_loop(body)
#:if grad_val is None
DO kgrad=1,grad_val
$:  body
ENDDO
#:else
#:for i in range(1, grad_val+1)
$:  body.replace('kgrad',str(i))
#:endfor
#:endif
#:enddef kgrad_loop
#!--------------------------------------------------------------------------------------------------

#:set postfix = "int" if FMG_INTEGRATE_FULL else "col"
#:if grad_val is None
! **************************************************************************************************
!> \brief Default version for any grad with Fortran loops
!> \param grad_val ...
! **************************************************************************************************
   SUBROUTINE kloopdefault_${postfix}$(grad_val)
   INTEGER, INTENT(IN)                             :: grad_val
#:else
! **************************************************************************************************
!> \brief Optimized version for grad=${grad_val}$ with unrolled loops.
! **************************************************************************************************
  SUBROUTINE kloop${grad_val}$_${postfix}$()
  INTEGER, PARAMETER                               :: grad_val = ${grad_val}$
#:endif

#:if not FMG_INTEGRATE_FULL
    CALL poly_p_eval2b(p=IF_CHECK(poly_jk,poly_jk(1)), &
                       size_p=size_jk, &
                       x=REAL(j,dp), &
                       pRes=IF_CHECK(poly_k,poly_k(0)), &
                       size_pRes=size_k, &
                       npoly=npoly, &
                       grad=grad_val, &
                       xi=IF_CHECK(xi,xi(1)))
#:endif

    ! starting point
    kJump=ndim(2)-l_bounds(2,2)+l_bounds(1,2)
    kstart=MAX(0,kmin)
    ikShift=shiftPos(2)-l_bounds(2,2)+kstart
    IF (ikShift>0) ikShift=ikShift+ndim(2)-1
    ikShift=(ikShift/ndim(2))*ndim(2)-shiftPos(2)
    ! ikShift=CEILING(REAL(shiftPos(2)-l_bounds(2,2)+kstart)/REAL(ndim(2)))*ndim(2)-shiftPos(2)
    kstart=MAX(ikShift+l_bounds(1,2),kstart)
    kend=MIN(ikShift+l_bounds(2,2),kmax)
    ikstart=kstart-ikShift-l_bounds(1,2)+l_shift(2)
    kstart2=MIN(-1,kmax)
    ikShift2=shiftPos(2)+kstart2-l_bounds(1,2)
    IF (ikShift2<0) ikShift2=ikShift2-ndim(2)+1
    ikShift2=(ikShift2/ndim(2))*ndim(2)-shiftPos(2)
    !ikShift2=FLOOR(REAL(shiftPos(2)+kstart2-l_bounds(1,2))/REAL(ndim(2)))*ndim(2)-shiftPos(2)
    kstart2=MIN(ikShift2+l_bounds(2,2),kstart2)
    kend2=MAX(ikShift2+l_bounds(1,2),kmin)
    ikstart2=kstart2-ikShift2-l_bounds(1,2)+l_shift(2)

#:if FMG_INTEGRATE or FMG_INTEGRATE_FULL
    k_vals=0.0_dp
#:endif

    IF (kJump/=1 .AND. (ikstart+kmax-kstart>=ndim(2)+l_shift(2) .OR.&
        ikstart2+kmin-kstart2<=l_ub(2)-ndim(2))) THEN
        ! will wrap
        ! pos k side
        k_coeffn_k=k_coeffn_j
        kk_coeffn=k_coeffn_k*kk_coeff0
        res_k=res_j
        k=kstart
        ik=ikstart
        IF (k>0) THEN
            kk_coeffn=k_coeffn_k*kk_coeff0**(2*kstart+1)
            res_k=res_j*(kk_coeff0**kstart*k_coeffn_k)**kstart
        END IF
        DO
            DO k=kstart,kend
#:if FMG_INTEGRATE or FMG_INTEGRATE_FULL
                gval=IF_FLAT(grid(ii+ij+ik+1),grid(ik,ij,ii))*res_k
                k_vals(0)=k_vals(0)+gval
                p_kk=gval
#:call kgrad_loop
                p_kk=p_kk*REAL(k,dp)
                k_vals(kgrad)=k_vals(kgrad)+p_kk
#:endcall kgrad_loop
#:else
                p_v=poly_k(0)
                p_kk=REAL(k,dp)
#:call kgrad_loop
                p_v=p_v+poly_k(kgrad)*p_kk
                p_kk=p_kk*REAL(k,dp)
#:endcall kgrad_loop
#:if FM_FLAT_GRID
                grid(ii+ij+ik+1) = grid(ii+ij+ik+1) + p_v*res_k
#:else
                IF ( PRESENT ( lgrid ) ) THEN
                  ig = ii * (l_bounds(2,2)-l_bounds(1,2)+1) * (l_bounds(2,1)-l_bounds(1,1)+1) + &
                       ij * (l_bounds(2,2)-l_bounds(1,2)+1) + ik + 1
                  lgrid%r(ig,ithread)=lgrid%r(ig,ithread) + p_v*res_k
                ELSE
                  grid(ik,ij,ii) = grid(ik,ij,ii) + p_v*res_k
                END IF
#:endif
#:endif

                res_k=res_k*kk_coeffn
                kk_coeffn=kk_coeffn*kk_coeff2
                ik=ik+1
            END DO
            kstart=kend+kJump
            IF (kstart>kmax) EXIT
            kend=MIN(kend+ndim(2),kmax)
            ik=l_shift(2)
            kk_coeffn=k_coeffn_k*kk_coeff0**(2*kstart+1)
            res_k=res_j*(kk_coeff0**kstart*k_coeffn_k)**kstart
        END DO

        ! neg k side
        k_coeffn_k=1.0_dp/k_coeffn_j
        kk_coeffn=k_coeffn_k*kk_coeff0
        res_k=res_j
        k=kstart2
        ik=ikstart2
        IF (k<-1) THEN
            kk_coeffn=k_coeffn_k*kk_coeff0**(-(2*kstart2+1))
            res_k=res_j*(kk_coeff0**(-kstart2-1)*k_coeffn_k)**(-kstart2-1)
        END IF
        DO
            DO k=kstart2,kend2,-1
                res_k=res_k*kk_coeffn
                kk_coeffn=kk_coeffn*kk_coeff2
#:if FMG_INTEGRATE or FMG_INTEGRATE_FULL
                gval=IF_FLAT(grid(ii+ij+ik+1),grid(ik,ij,ii))*res_k
                k_vals(0)=k_vals(0)+gval
                p_kk=gval
#:call kgrad_loop
                p_kk=p_kk*REAL(k,dp)
                k_vals(kgrad)=k_vals(kgrad)+p_kk
#:endcall kgrad_loop
#:else
                p_v=poly_k(0)
                p_kk=k
#:call kgrad_loop
                    p_v=p_v+poly_k(kgrad)*p_kk
                    p_kk=p_kk*k
#:endcall kgrad_loop
#:if FM_FLAT_GRID
                grid(ii+ij+ik+1) = grid(ii+ij+ik+1) + p_v*res_k
#:else
                IF ( PRESENT ( lgrid ) ) THEN
                  ig = ii * (l_bounds(2,2)-l_bounds(1,2)+1) * (l_bounds(2,1)-l_bounds(1,1)+1) + &
                       ij * (l_bounds(2,2)-l_bounds(1,2)+1) + ik + 1
                  lgrid%r(ig,ithread)=lgrid%r(ig,ithread) + p_v*res_k
                ELSE
                  grid(ik,ij,ii) = grid(ik,ij,ii) + p_v*res_k
                END IF
#:endif
#:endif
                ik=ik-1
            END DO
            kstart2=kend2-kJump
            IF (kstart2<kmin) EXIT
            kend2=MAX(kend2-ndim(2),kmin)
            ik=l_ub(2)
            kk_coeffn=k_coeffn_k*kk_coeff0**(-(2*kstart2+1))
            res_k=res_j*(kk_coeff0**(-kstart2-1)*k_coeffn_k)**(-kstart2-1)
        END DO
    ELSE
        ! no jump
        ! pos k side
        k_coeffn_k=k_coeffn_j
        kk_coeffn=k_coeffn_k*kk_coeff0
        res_k=res_j
        k=kstart
        ik=ikstart
        IF (k>0) THEN
            kk_coeffn=k_coeffn_k*kk_coeff0**(2*kstart+1)
            res_k=res_j*(kk_coeff0**kstart*k_coeffn_k)**kstart
        END IF
        DO
            DO k=kstart,kend
#:if FMG_INTEGRATE or FMG_INTEGRATE_FULL
                gval=IF_FLAT(grid(ii+ij+ik+1),grid(ik,ij,ii))*res_k
                k_vals(0)=k_vals(0)+gval
                p_kk=gval
#:call kgrad_loop
                    p_kk=p_kk*REAL(k,dp)
                    k_vals(kgrad)=k_vals(kgrad)+p_kk
#:endcall kgrad_loop
#:else
                p_v=poly_k(0)
                p_kk=REAL(k,dp)
#:call kgrad_loop
                    p_v=p_v+poly_k(kgrad)*p_kk
                    p_kk=p_kk*REAL(k,dp)
#:endcall kgrad_loop
#:if FM_FLAT_GRID
                grid(ii+ij+ik+1) = grid(ii+ij+ik+1) + p_v*res_k
#:else
                IF ( PRESENT ( lgrid ) ) THEN
                  ig = ii * (l_bounds(2,2)-l_bounds(1,2)+1) * (l_bounds(2,1)-l_bounds(1,1)+1) + &
                       ij * (l_bounds(2,2)-l_bounds(1,2)+1) + ik + 1
                  lgrid%r(ig,ithread)=lgrid%r(ig,ithread) + p_v*res_k
                ELSE
                  grid(ik,ij,ii) = grid(ik,ij,ii) + p_v*res_k
                END IF
#:endif
#:endif

                res_k=res_k*kk_coeffn
                kk_coeffn=kk_coeffn*kk_coeff2
                ik=ik+1
            END DO
            kstart=kend+kJump
            IF (kstart>kmax) EXIT
            kend=MIN(kend+ndim(2),kmax)
            ik=l_shift(2)
        END DO

        ! neg k side
        k_coeffn_k=1.0_dp/k_coeffn_j
        kk_coeffn=k_coeffn_k*kk_coeff0
        res_k=res_j
        k=kstart2
        ik=ikstart2
        IF (k<-1) THEN
            kk_coeffn=k_coeffn_k*kk_coeff0**(-(2*kstart2+1))
            res_k=res_j*(kk_coeff0**(-kstart2-1)*k_coeffn_k)**(-kstart2-1)
        END IF
        DO
            DO k=kstart2,kend2,-1
                res_k=res_k*kk_coeffn
                kk_coeffn=kk_coeffn*kk_coeff2
#:if FMG_INTEGRATE or FMG_INTEGRATE_FULL
                gval=IF_FLAT(grid(ii+ij+ik+1),grid(ik,ij,ii))*res_k
                k_vals(0)=k_vals(0)+gval
                p_kk=gval
#:call kgrad_loop
                    p_kk=p_kk*REAL(k,dp)
                    k_vals(kgrad)=k_vals(kgrad)+p_kk
#:endcall kgrad_loop
#:else
                p_v=poly_k(0)
                p_kk=k
#:call kgrad_loop
                    p_v=p_v+poly_k(kgrad)*p_kk
                    p_kk=p_kk*k
#:endcall kgrad_loop
#:if FM_FLAT_GRID
                grid(ii+ij+ik+1) = grid(ii+ij+ik+1) + p_v*res_k
#:else
                IF ( PRESENT ( lgrid ) ) THEN
                  ig = ii * (l_bounds(2,2)-l_bounds(1,2)+1) * (l_bounds(2,1)-l_bounds(1,1)+1) + &
                       ij * (l_bounds(2,2)-l_bounds(1,2)+1) + ik + 1
                  lgrid%r(ig,ithread)=lgrid%r(ig,ithread) + p_v*res_k
                ELSE
                  grid(ik,ij,ii) = grid(ik,ij,ii) + p_v*res_k
                END IF
#:endif
#:endif
                ik=ik-1
            END DO
            kstart2=kend2-kJump
            IF (kstart2<kmin) EXIT
            kend2=MAX(kend2-ndim(2),kmin)
            ik=l_ub(2)
        END DO
    END IF
#:if FMG_INTEGRATE
    pShift=0
    DO ipoly=1,npoly
        p_v=0.0_dp
        p_v=p_v+poly_k(pShift)*k_vals(0)
#:call kgrad_loop
            p_v=p_v+poly_k(pShift+kgrad)*k_vals(kgrad)
#:endcall kgrad_loop
        mres(ipoly)=mres(ipoly)+p_v
        pShift=pShift+grad_val+1
    END DO
#:elif FMG_INTEGRATE_FULL
    CALL poly_padd_uneval2b(p=IF_CHECK(poly_jk,poly_jk(1)), &
                            size_p=size_jk, &
                            x=REAL(j,dp), &
                            pRes=IF_CHECK(k_vals,k_vals(0)), &
                            size_pRes=size_k, &
                            npoly=npoly, &
                            grad=grad_val, &
                            xi=IF_CHECK(xi,xi(1)))
#:endif

#:if grad_val is None
   END SUBROUTINE kloopdefault_${postfix}$
#:else
  END SUBROUTINE kloop${grad_val}$_${postfix}$
#:endif

#:enddef colloc_int_kloop
#:endmute
